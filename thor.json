{
  "version": "0.1.1",
  "date": {
    "description": "Log entries by date",
    "children": {
      "20181120": {
        "description": "Thinking about the unification of the three main servers, Wotan, Heimdall, and Freya.",
        "children": {
          "the lifetime of a client request": "The client wants information. How can they access that information? What kind of client are they? The client wants one of two things: (a) an immediate response to their question, or (b) a scheduled or triggered calculation that will deliver the information to them as soon as it is ready. To achieve (a), all you need is a server that responds to every question with data that can be read or calculated nearly instantly. To achieve (b), two additional servers, or at least 'concerns' are required. First, how do I get in touch with the client later when I have the information? Second, how do I know what 'later' means? All of this could be done with a single server, but it is cleaner to separate the concerns into three parts. Wotan is a synchronous web server that only stores data and responds to questions as fast as it possibly can. Heimdall is an asyncronous websocket server that maintains connections with the actual clients, but relays all incoming messages to Wotan, and relays all replies from Wotan to the correct client. If a task needs to be run on a regular basis, the first cause of that need must come from a client message to Heimdall, then to Wotan, and finally to Freya, who makes a record of the task in her database. The task encodes only a package that must be sent to Wotan when the time is right. Wotan will run the method, sending the output to Heimdall as usual, who will then relay it to the correct client.",
        }
      },
      "20181125": {
        "description": "Need to prepare for 1.0 release. This needs to be the simplest version of the software. All mechanical aspects are in place. All that remains is the deployment.",
        "children": {
          "simplest deployment": "Probably the best way to do this is to use the setup I had before with asgi and redis using Django only. This would require some modifications to the Wotan package. I should have everything running on the same machine. I should also put the Django code behind Daphne and nginx. This can be added as a part of the yggdrasil configuration."
        }
      },
      "20190301": {
        "description": "As I think of what is needed to move into production, I think about the state of the application compared to that in my work. In my work, I see low-cost incremental changes made in favour of large, breaking changes. This makes sense, but passes over much needed refactoring. I see the same thing in this project, since it has now grown large enough that any change is daunting, or at least changes that would change fundamentally how the application works. I have questions in my mind about continuous deployment, database migrations, multiple backends and frontends, etc. If I were to construct a huge web of nodes, then things would inevitably slow down. Talking with SJ, I realise that in order to have any record of changes that is without error, a system such as a blockchain that enforces order is necessary. The further you decentralise, the more you need an enforcement mechanism for changes in order to remain in sync. The source of truth must be singular.",
        "children": {
          "sources of truth": "It seems foolish, but it might be worth considering how something would work with many sources of truth, or at least deal with a fragmentation of the truth. For example, a web application might rely on a backend server for data, but at what point could it consider its own local data store as most truthy? A real-world example is the web application that I am building in my work. Data is polled every ten seconds, but if a change is made locally, what is true? If a user toggles a value, they should expect to see that change immediately, and for it to stay that way, despite a possible incoming update from the backend. Maybe applications should learn to deal with multiple sources of truth, rather than asymptotically approaching the blockchain model.",
          "superadmin": "",
          "more complex data from the blockchain": "",
        }
      },
      "20190302": {
        "description": "Thinking about what needs to be done to show this to a company. It must be polished and usable enough on the surface that it can immediately form a crucial part of a larger application without jeapordising security, assuming my ideas about security are good at all. There are some things I will not do, like use tokens or usernames and passwords in some web 2.0 interface.",
        "children": {
          "email": "It's possible, like the company in the JBS, that any client I do find will want the values emailed to them directly. I don't need to do this now, but it would be an easy changes to make; adding an Email object to the database and adding a trigger to a task. This can be done quickly if needed.",
          "encrypt solved challenge": "A solved challenge should be re-encrypted to the public key of the system.",
          "admin backdoor": "The problem with adding a backdoor, is that despite any precaution taken to prevent an intruder from discovering it, its chance of discovery is still proportional to how easy it is to use. It will be found, especially if any part of the source code is shared. What might make more sense is to simply create an admin account and follow the path to fully encrypted communications.",
          "encrypted channel": "Just like the 'schema' section of the schema, there should be an 'encrypted' section fo the schema that takes only a string input. It assumes this string is an encrypted blob of data representing the same JSON structure that would have been sent to the 'schema' section, but instead encrypted to the public key of the system and signed by the private key of the user. This should be accepted from any IP address or source, and would return an encrypted blob of data with exactly the same structure as would have been returned as the response to a normal request, except that it will appear only as a single string."
        }
      },
      "20190322": {
        "description": "Getting very close to a release-worthy product. After adding a couple things, such as a System object for access to the system public key and a modified Address get method that returns an address for a specific ID referenced in a payment, it becomes usuable as a stand-alone service. The backend will still point at other APIs for now, but hopefully, will soon point at its own node backend.",
        "children": {
          "t12.2": {
            "description": "Add system schema",
            "children": {
              "add system schema": "Should only need a simple get method. Perhaps the ability to filter the properties returned, such as public key and signed disclaimer."
            }
          },
          "t12.3": {
            "description": "Modify address get method to allow filtering by ID",
            "children": {
              "modify address get": "Should be able to fetch address by ID. This will allow payments to be made at any time by fetching the required address value from the ID stored in the payment object.",
            }
          }
        }
      }
    }
  }
}
